---
allowed-tools: Read, Write, LS
---

# 创建新的产品需求文档

启动新功能的产品需求文档头脑风暴。

## 用法
```
/dd:prd-new <功能名称>
```

## 必要规则

**重要：** 执行此命令前，请阅读并遵循：
- `.claude/rules/datetime.md` - 获取真实的当前日期时间

## 预检清单

执行前完成这些验证步骤。
不要打扰用户预检进度（"我不会..."），直接执行并继续。

### 输入验证
1. **验证功能名称格式：**
   - 只能包含小写字母、数字和连字符
   - 必须以字母开头
   - 不允许空格或特殊字符
   - 如果无效，告诉用户："❌ 功能名称必须是 kebab-case 格式（仅小写字母、数字、连字符）。示例：用户认证、支付-v2、通知系统"

2. **检查现有 PRD：**
   - 检查 `.claude/prds/$ARGUMENTS.md` 是否已存在
   - 如果存在，询问用户："⚠️ PRD '$ARGUMENTS' 已存在。是否覆盖？(是/否)"
   - 只有明确确认 '是' 才继续
   - 如果用户说否，建议："使用不同名称或运行：/dd:prd-parse $ARGUMENTS 从现有 PRD 创建执行计划"

3. **验证目录结构：**
   - 检查 `.claude/prds/` 目录是否存在
   - 如果不存在，先创建它
   - 如果无法创建，告诉用户："❌ 无法创建 PRD 目录。请手动创建：.claude/prds/"

## 操作指南

你是一位产品经理，正在为功能 **$ARGUMENTS** 创建全面的产品需求文档（PRD）。

遵循这种结构化方法：

### 1. 发现与上下文
- 询问关于功能/产品 "$ARGUMENTS" 的澄清问题
- 了解要解决的问题
- 识别目标用户和用例
- 收集约束和需求

### 2. PRD 结构
创建包含以下部分的全面 PRD：

#### 执行摘要
- 简要概述和价值主张

#### 问题陈述
- 我们在解决什么问题？
- 为什么现在很重要？

#### 用户故事
- 主要用户角色
- 详细的用户旅程
- 正在解决的痛点

#### 需求
**功能需求**
- 核心功能和能力
- 用户交互和流程

**非功能需求**
- 性能期望
- 安全考虑
- 可扩展性需求

#### 成功标准
- 可衡量的结果
- 关键指标和 KPI

#### 约束与假设
- 技术限制
- 时间线约束
- 资源限制

#### 范围外
- 我们明确不构建的内容

#### 依赖关系
- 外部依赖
- 内部团队依赖

### 3. 带前置元数据的文件格式
将完成的 PRD 保存到：`.claude/prds/$ARGUMENTS.md`，使用以下确切结构：

```markdown
---
名称: $ARGUMENTS
描述: [PRD 的简短一行描述]
状态: backlog
创建时间: [当前 ISO 日期时间]
---

# PRD: $ARGUMENTS

## 执行摘要
[内容...]

## 问题陈述
[内容...]

[继续所有部分...]
```

### 4. 前置元数据指南
- **名称**：使用确切的功能名称（与 $ARGUMENTS 相同）
- **描述**：写一个关于此 PRD 涵盖内容的简洁一行摘要
- **状态**：新 PRD 始终以 "backlog" 开始
- **创建时间**：运行以下命令获取真实当前日期时间：`date -u +"%Y-%m-%dT%H:%M:%SZ"`
  - 永不使用占位符文本
  - 必须是 ISO 8601 格式的实际系统时间

### 5. 质量检查

保存 PRD 之前，验证：
- [ ] 所有部分都完整（没有占位符文本）
- [ ] 用户故事包含验收标准
- [ ] 成功标准是可衡量的
- [ ] 依赖关系明确识别
- [ ] 范围外项目明确列出

### 6. 创建后

成功创建 PRD 后：
1. 确认："✅ PRD 已创建：.claude/prds/$ARGUMENTS.md"
2. 显示捕获内容的简要摘要
3. 建议下一步："准备创建实施计划？运行：/dd:prd-parse $ARGUMENTS"

## 错误恢复

如果任何步骤失败：
- 清楚解释出了什么问题
- 提供解决问题的具体步骤
- 永不留下部分或损坏的文件

在编写 PRD 之前，对 "$ARGUMENTS" 进行彻底的头脑风暴会议。提问题，探索边缘情况，确保全面覆盖功能需求。