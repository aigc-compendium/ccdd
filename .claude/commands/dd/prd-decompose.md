---
allowed-tools: Task, Read, Write, Edit, Bash, Glob, Grep
---

# DD 需求拆解命令

基于 PRD 和架构设计, 将项目需求拆解为大功能模块, 为新项目规划完整的功能开发路径.

## 核心功能

### 1. 需求模块拆解

- 分析 PRD 文档中的用户需求
- 结合架构设计确定技术边界
- 拆解为独立的大功能模块
- 确保功能模块的内聚性和松耦合

### 2. 依赖关系分析

- 分析功能模块间的依赖关系
- 识别核心基础模块和业务模块
- 确定模块开发的先后顺序
- 避免循环依赖和复杂依赖

### 3. 开发优先级规划

- 基于业务价值和技术复杂度排序
- 考虑 MVP(最小可行产品)需求
- 规划迭代开发计划
- 平衡风险和收益

### 4. 智能功能拆解和用户确认

- 基于分析结果给出功能拆解方案
- 与用户讨论确认每个功能模块
- 支持多轮调整和优化
- 最终确认完整的功能列表

### 5. 自动批量添加功能

确认拆解方案后, 遍历调用 `/dd:feature-add` <feature_name> 为每个功能创建完整文档结构

## 执行流程

### 1. 上下文加载和分析

使用 Task 工具调用 deep-thinker 智能体进行深度分析:

```bash
# 1. 读取项目上下文
# - .claude/context/project.md
# - .claude/context/architecture.md  
# - PRD 相关文档

# 2. 进行深度思考分析
# - 需求完整性分析
# - 技术可行性评估  
# - 模块划分合理性判断
# - 依赖关系复杂度评估
```

### 2. 功能拆解方案设计

AI 基于分析结果提出功能拆解方案:

- 定义每个功能模块的边界和职责
- 分析功能间的依赖关系
- 评估开发优先级和复杂度
- 提供详细的功能描述

### 3. 用户确认和调整

与用户进行深度对话:

- 展示完整的功能拆解方案
- 讨论每个功能的必要性和边界
- 根据用户反馈调整拆解方案
- 支持多轮优化直至用户满意

### 4. 批量创建功能文档

用户确认后, 自动执行:

```bash
# 遍历确认的功能列表, 为每个功能调用
/dd:feature-add <功能1名称>
/dd:feature-add <功能2名称>
/dd:feature-add <功能3名称>
# ... 直到所有功能创建完成
```

## 输出格式

生成 `.claude/context/requirements-breakdown.md` 文档:

```markdown
---
breakdown_date: 2024-01-15T10:30:00Z
total_modules: 8
estimated_weeks: 16
complexity: 中等
priority_order: [模块1, 模块2, ...]
---

# 项目需求拆解方案

## 功能模块概览

### 1. 模块名称

- **功能描述**: [模块核心功能和价值]
- **技术复杂度**: 简单|中等|复杂
- **优先级**: 高|中|低
- **预估工时**: X 周
- **依赖模块**: [前置依赖模块]
- **风险评估**: [技术风险和缓解措施]

## 开发路径规划

### 第一阶段 (核心基础)

- 模块 A: 用户认证系统
- 模块 B: 数据层设计

### 第二阶段 (核心业务)

- 模块 C: 业务逻辑核心
- 模块 D: API 接口层

### 第三阶段 (增强功能)

- 模块 E: 高级特性
- 模块 F: 性能优化

## 依赖关系图
```

[ASCII 依赖关系图或文字描述]

```

## MVP 功能范围
第一阶段完成后可交付的最小可行产品功能列表

## 风险分析
主要技术风险、资源风险和时间风险的识别和应对策略
```

## 完成后提示

命令执行完成后, 向用户提示:

```
🎯 功能拆解和批量创建完成！
📋 已创建 {X} 个功能模块，包含完整文档结构
⏱️ 预估总开发时间: {Y} 周

✅ 已完成功能创建:
   - 功能1: 生成 overview.md, technical.md, acceptance.md
   - 功能2: 生成 overview.md, technical.md, acceptance.md
   - ...

📝 建议下一步操作:
   /dd:feature-decompose <第一优先级功能名>  # 开始议题拆解

💡 或查看完整拆解方案:
   查看 .claude/context/requirements-breakdown.md
```

## 深度思考要点

### 模块划分原则

- **单一职责**: 每个模块专注一个核心功能域
- **高内聚低耦合**: 模块内部紧密协作, 模块间接口清晰
- **可维护性**: 模块边界清晰, 便于独立开发和维护
- **可扩展性**: 预留未来功能扩展的接口和空间

### 技术债务考虑

- 识别可能的技术债务积累点
- 规划重构和优化的时间窗口
- 平衡快速交付和代码质量
- 考虑维护成本和团队能力

### 风险缓解策略

- 为高风险模块准备备选方案
- 建立原型验证关键技术假设
- 规划增量交付和用户反馈循环
- 预留缓冲时间处理不可预见问题

## 文档生成规范

### 文档格式要求

所有生成的文档内容必须遵循以下格式规范：

- **中英文混合文本**：英文单词与中文字符之间必须有一个空格
- **示例**：`这是一个 API 接口层` 而不是 `这是一个API接口层`
- **列表项格式**：多个功能模块必须分行显示，每行以 "- " 开头
- **正确示例**：
  ```
  - 用户认证系统
  - 数据管理模块
  - API 接口层
  ```
- **错误示例**：`用户认证系统|数据管理模块|API接口层`
- **适用范围**：所有功能模块描述、技术分析、开发计划等

## 使用场景

### 新项目启动

在完成 `dd:framework-init` 架构设计后, 使用此命令将整个项目需求拆解为可管理的功能模块, 建立清晰的开发路径.

### 大型功能规划

对于复杂的业务需求, 先进行需求拆解可以更好地理解问题域, 避免功能设计时遗漏关键环节.

### 团队协作规划

通过需求拆解可以更好地分配开发议题, 让团队成员理解整体架构和各自负责的模块边界.
